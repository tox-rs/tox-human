<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Onion client (UDP)</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="static/pandoc.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      jax: ["input/TeX", "output/HTML-CSS"],
      MathML: {
        extensions: ["content-mathml.js"]
      },
      "HTML-CSS": { webFont: "Neo-Euler" }
    });
  </script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Onion client (UDP)</h1>
</header>
<p>This is a description of onion layer in Tox.</p>
<h2 id="paths">Paths</h2>
<p>Onion routing can be described using this chart:</p>
<object data="static/path.svg" type="image/svg+xml">
</object>
<p>To send a message via an onion path, first we construct the path by choosing three random nodes. Then, we put the message in several layers:</p>
<ol>
<li><code>OnionRequest2</code> contains the address of the message receiver and the message encrypted with the third's node key</li>
<li><code>OnionRequest1</code> contains the address of the second node and <code>OnionRequest2</code> encrypted with the second's node key, and</li>
<li><code>OnionRequest0</code> contains the address of the first node and encrypted <code>OnionRequest0</code></li>
</ol>
<p>A node that belongs to the path receives a message, decrypts the payload, attaches <code>OnionReturn</code> and sends the result to the next node in the path.</p>
<p>An <code>OnionReturn</code> of the n'th node is the pair of <code>IP_Port</code> and <code>OnionReturn</code> of the previous node (if it exists), encrypted with the n'th node's key. It allows the receiver to send a response to the sender using the same onion path.</p>
<h2 id="client-announce">Client announce</h2>
<p>An iteration of self announce:</p>
<ol>
<li>Clean up the <code>announce_list</code> from timeouted nodes</li>
<li>For node <code>n</code> in <code>announce_list</code>:
<ul>
<li>If the node is out of ping credit, skip it</li>
<li>Check whether the node is not announced, announced or stable</li>
<li>If it's time to send an announce request, send it to the node
<ul>
<li>Update time and increment <code>ping_debt</code> of the node</li>
</ul></li>
</ul></li>
<li>If <code>announce_list</code> is not full, choose whether we should send to a path node
<ul>
<li>If so, send the announce request to a random path node (ping_id = 0)</li>
</ul></li>
</ol>
<p>A node is considered <em>timeouted</em> if the last ping was more than <code>NODE_TIMEOUT</code> seconds ago and the node is out of ping credit.</p>
<p>A node is <em>out of ping credit</em> if <code>ping_debt</code> of the node is more than <code>MAX_NODE_PINGS</code>.</p>
<p>A node is <em>announced</em> if <code>is_stored</code> is not <code>0</code> and client's <code>self_paths</code> contains a path with the <code>path_num</code> of the node. An announced node is called <em>stable</em> if the node by itself is stable and the corresponding path is stable.</p>
<p>A node is <em>stable by itself</em> if it was added more than <code>TIME_TO_STABLE</code> seconds ago, its <code>ping_debt</code> is zero, the node was pinged less than <code>NODE_TIMEOUT</code> seconds ago.</p>
<p>A path is called <em>stable</em> if it was created more than <code>TIME_TO_STABLE</code> seconds ago, the <code>usage_debt</code> of the path is zero and the path was not used for more than <code>PATH_TIMEOUT</code>.</p>
<p>It is time to send an announce request if:</p>
<ol>
<li>A node was pinged more than <code>interval</code> seconds ago, where <code>interval</code> is one of <code>ANNOUNCE_INTERVAL_NOT_ANNOUNCED</code>, <code>ANNOUNCE_INTERVAL_ANNOUNCED</code>, <code>ANNOUNCE_INTERVAL_STABLE</code>, depending on the node type</li>
<li>Or the last announce was more than <code>NODE_PING_INTERVAL</code> seconds ago and <code>random(MAX_ONION_CLIENTS_ANNOUNCE - i) == 0</code>, where <code>i</code> is the index of the node in the <code>announce_list</code></li>
</ol>
<p>The process of sending a self announce request to a node is the following:</p>
<ol>
<li>First, get a random path with a given <code>path_num</code>.</li>
<li>Store a sendback in <code>announce_ping_array</code>, getting the sendback_id</li>
<li>Construct an announce request payload with
<ul>
<li><code>search_id = real_pk</code></li>
<li><code>data_pk = temp_pk</code></li>
<li><code>ping_id = ping_id</code></li>
<li><code>sendback_data = sendback_id</code>
<ul>
<li>Where <code>real_pk</code> is the real public key, <code>temp_pk</code> is the temporary public key of the onion client.</li>
</ul></li>
</ul></li>
<li>The payload is encrypted using <code>{dest_pk, real_sk}</code>, where <code>dest_pk</code> is the public key of the destination, <code>real_sk</code> is the real secret key</li>
<li>Construct the request with the payload and <code>{pk = real_pk}</code></li>
<li>Send the request via the onion path</li>
</ol>
<p>Getting a random path:</p>
<ol>
<li>If <code>path_num</code> is not <code>None</code>, set <code>path_index = path_num % NUMBER_ONION_PATHS</code>. Otherwise, set <code>path_index = random(0..NUMBER_ONION_PATHS)</code></li>
<li>If <code>path_list[path_index]</code> is timed out or doesn't exist:
<ol>
<li>Get <code>ONION_PATH_LENGTH</code> random path nodes</li>
<li>Check whether the last node belongs to some path</li>
<li>If yes, then use that path</li>
<li>If not:
<ol>
<li>Create a new onion path</li>
<li>Set times for the path</li>
<li>Set <code>path_num = r(random_u32(), NUMBER_ONION_PATHS) + path_index</code>, where <span class="math inline">\(r(a, n) = a - (a \bmod n)\)</span> – a “modulo rounding” function</li>
</ol></li>
</ol></li>
<li>Otherwise, just use the existing path</li>
<li>If the path is not out of usage credit, update <code>last_path_used</code></li>
<li>Increment the usage debt of the path</li>
<li>Return the path</li>
</ol>
<p>An announce response is handled in the following way:</p>
<ol>
<li>Get the sendback from <code>announce_ping_array</code> using the <code>sendback_data</code></li>
<li>Decrypt the payload using <code>{sb.node.pk, real_sk}</code>, where <code>sb.node.pk</code> is the public key stored in the sendback, <code>real_sk</code> is the real secret key</li>
<li>Set path timeouts using <code>{sb.friend_num, sb.path_num}</code></li>
<li>Add the announce node to <code>announce_list</code></li>
<li>Add the node to <code>path_nodes</code></li>
<li>Get nodes from the payload and ping them (if any)</li>
</ol>
<p>The process of pinging a node is the following:</p>
<ol>
<li>Clean up <code>announce_list</code> from timeouted nodes</li>
<li>A node in the payload is pinged if:
<ol>
<li>It is closer to us than nodes in the <code>announce_list</code> or the list is not full</li>
<li>And it doesn't belong to the list</li>
<li>And it is good to ping</li>
</ol></li>
<li>Pinging is sending an announce request with <code>ping_id = 0</code> via a random path</li>
</ol>
<p>A node is good to ping if this is not the last pinged node unless the node was pinged more than <code>MIN_NODE_PING_TIME</code> ago.</p>
<p>A sequence chart for the beginning of self announce process (messages are sent via onion):</p>
<object data="static/announce_start.svg" type="image/svg+xml">
</object>
<h2 id="friend-search-and-dhtpk-announce">Friend search and DHTPK announce</h2>
<p>The overall process has two steps:</p>
<ul>
<li>First, we use announce requests to find announce nodes that stores paths to our friend
<ul>
<li>This process is similar to the announce process</li>
</ul></li>
<li>Then, we send (via onion) <code>DataRequest</code> to found announce nodes</li>
</ul>
<p>This is the chart of the second step:</p>
<object data="static/dhtpk.svg" type="image/svg+xml">
</object>
<p>Specifically:</p>
<ol>
<li>We start with constructing <code>DhtPkData</code>:
<ul>
<li><code>no_replay = now</code> where <code>now</code> is the current time</li>
<li><code>dht_pk = dht_pk</code> where <code>dht_pk</code> is our dht public key</li>
<li><code>nodes = closest</code> where <code>closest</code> is a list of closest to us dht nodes</li>
</ul></li>
<li>Serialize it into bytes and send as an onion data or via dht</li>
</ol>
<p>The process of sending onion data is the following:</p>
<ol>
<li>The <code>client_list</code> of a friend is cleaned up of timeouted nodes</li>
<li>Good nodes are with <code>is_stored != 0</code></li>
<li>It should be more than <code>(num_nodes - 1) / 4 + 1</code> good nodes to continue where <code>num_nodes</code> is the number of nodes in <code>client_list</code></li>
<li>Generate a random nonce</li>
<li>The data is encrypted using friend's real public key, our real secret key and the nonce</li>
<li>Construct <code>OnionData</code>:
<ul>
<li><code>real_pk</code> is our real public key</li>
<li><code>dht_pk_data</code> is the encrypted data</li>
</ul></li>
<li>For each good node:
<ol>
<li>Get a random friend path</li>
<li>Construct a <code>DataRequest</code>:
<ul>
<li><code>dest_pk = friend.real_pk</code></li>
<li><code>nonce = nonce</code>. The same nonce that we used before</li>
<li><code>temp_pk = random_pk</code>. We generate a random keypair</li>
<li>The <code>payload</code> is the onion data encryped with the node's data public key and the random secret key, using the same <code>nonce</code></li>
</ul></li>
<li>Send the request via the onion path</li>
</ol></li>
</ol>
<h2 id="notes-on-data-structures">Notes on data structures</h2>
<p>Both <code>path_nodes</code> and <code>announce_list</code> are arrays of limited size. But the way they are updated are different.</p>
<p>When <code>path_nodes</code> is full, adding a new element replaces an old one in a circular manner: first adding an element replaces <code>path_nodes[0]</code>, then <code>path_nodes[1]</code>, and so on til we get to the end of the array. After that, we begin again with <code>path_nodes[0]</code>.</p>
<p><code>announce_list</code> is different. It is sorted by distance to real our public key. When an element is added, it is checked against the farest node. If the element is closer to us than the node, the node is removed and the element is inserted. Otherwise, the element is simply discarded.</p>
<p>Some packet data structures:</p>
<pre><code>struct DhtPkData {
    no_replay: u64,
    dht_pk: PublicKey,
    nodes: Vec&lt;PackedNode&gt;,
}

layout DhtPkData {
    u8 = ONION_DATA_DHTPK,
    u64,
    [u8; PUBLIC_KEY_SIZE],
    [[u8; PACKED_NODE_SIZE]; 0..MAX_SENT_NODES]
}</code></pre>
<h2 id="toxcore-notes">Toxcore notes</h2>
<p>In the C implementation, <code>ping_debt</code> and <code>usage_debt</code> are called <code>unsuccessful_pings</code> and <code>last_path_used_times</code> correspondingly. New names are chosen to represent the meaning of these variables more clearly.</p>
</body>
</html>
